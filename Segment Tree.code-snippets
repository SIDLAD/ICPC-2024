{
	"Segment Tree": {
		"scope":"cpp",
		"prefix": "segtree",
		"body": [
			"",
			"template <typename T ${2|= int|}, typename V ${3|= T|}>",
			"struct segtree",
			"{",
			"    int n;",
			"    vector<T> tree;",
			"    $1vector<V> lazy;",
			"    T zero ${4|= 0|}; // Change according to QUERY operation",
			"    $1V lazy_zero ${5|= 0|}; // Change according to MODIFY operation",
			"",
			"    segtree(int sz)",
			"    {",
			"        n = sz;",
			"        tree.clear();",
			"        $1lazy.clear();",
			"        tree.resize(2 * sz - 1, zero);",
			"        $1lazy.resize(2 * sz - 1, lazy_zero);",
			"    }",
			"",
			"    template <typename U>",
			"    segtree(vector<U> &v) : segtree(v.size())",
			"    {",
			"        build(v);",
			"    }",
			"",
			"    T combine(T a, T b)",
			"    {",
			"        // Change according to QUERY operation",
			"        ${6|return a + b;|}",
			"    }",
			"",
			"    template <typename U>",
			"    void build(vector<U> &v, int id = 0, int segl = 0, int segr = -1)",
			"    {",
			"        if (segr == -1)segr = n - 1;",
			"        if (segl == segr)",
			"        {",
			"            tree[id] ${7|= v[segl]|};  // Change according to MODIFY operation",
			"            return;",
			"        }",
			"        int mid = (segl + segr) / 2;",
			"        build(v, id + 1, segl, mid);",
			"        build(v, id + 2 * (mid - segl + 1), mid + 1, segr);",
			"        tree[id] = combine(tree[id + 1], tree[id + 2 * (mid - segl + 1)]);",
			"    }",
			"",
			"    $1void propagate(int id, int segl, int segr)",
			"    $1{",
			"    $1    if(lazy[id] == lazy_zero)return;",
			"    $1    if(segl != segr)",
			"    $1    {",
			"    $1        int mid = (segl + segr) / 2;",
			"    $1        array<int , 2> children= {id + 1, id + 2 * (mid - segl + 1)};",
			"    $1        for(auto child : children)",
			"    $1        {",
			"    $1            tree[child] ${10|= lazy[id]|};  // Change according to MODIFY operation",
			"    $1            lazy[child] ${11|= lazy[id]|};  // Change according to MODIFY operation",
			"    $1        }",
			"    $1    }",
			"    $1    lazy[id] = lazy_zero;",
			"    $1}",
			"",
			"    template <typename U>",
			"    void modify(U val, int index_l, int index_r, int id = 0, int segl = 0, int segr = -1)",
			"    {",
			"        if (segr == -1)segr = n - 1;",
			"        if (index_l > index_r || index_l > segr || segl > index_r)",
			"        {",
			"            return;",
			"        }",
			"        $1propagate(id, segl, segr);",
			"        ",
			"        if (segl >= index_l && segr <= index_r)",
			"        {",
			"            tree[id] ${8|= val|}; // Change according to MODIFY operation", 
			"            $1lazy[id] ${9|= val|}; // Change according to MODIFY operation",
			"            return;",
			"        }",
			"        int mid = (segl + segr) / 2;",
			"        modify(val, index_l, index_r, id + 1, segl, mid);",
			"        modify(val, index_l, index_r, id + 2 * (mid - segl + 1), mid + 1, segr);",
			"        tree[id] = combine(tree[id + 1], tree[id + 2 * (mid - segl + 1)]);",
			"    }",
			"    template <typename U>",
			"    auto modify(U val, int index) { return modify(val, index, index); }",
			"",
			"    T query(int index_l, int index_r, int id = 0, int segl = 0, int segr = -1)",
			"    {",
			"        if (segr == -1)segr = n - 1;",
			"        if (index_l > index_r || index_l > segr || segl > index_r)",
			"        {",
			"            return zero;",
			"        }",
			"        $1propagate(id, segl, segr);",
			"        ",
			"        if (segl >= index_l && segr <= index_r)",
			"        {",
			"            return tree[id];",
			"        }",
			"        int mid = (segl + segr) / 2;",
			"        T leftVal = query(index_l, index_r, id + 1, segl, mid);",
			"        T rightVal = query(index_l, index_r, id + 2 * (mid - segl + 1), mid + 1, segr);",
			"        return combine(leftVal, rightVal);",
			"    }",
			"    auto query(int index) { return query(index, index); }",
			"};",
			""
		],
		"description": ""
	}
}
